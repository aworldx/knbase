---
title: Indexes
keywords: db
summary: "This is just a sample topic..."
sidebar: knbase_sidebar
permalink: db_indexes.html
folder: knbase
---

## Виды индексов в postgres

Postgres поддерживает 5 типов индексов:
- B-дерево,
- хеш
- GiST
- SP-GiST
- GIN
- BRIN

### Особенности B-дерева
- индекс по умолчанию в Rails
- самый популярный
- работает только с сортируемыми данными: < <= = >= >
- может быть составным (важен порядок колонок)

![alt text](images/knbase/db/index.png "Title")

### Особенности хеш индекса
- работает только с простыми условиями равенства
- не рекомендуется их использовать

### GiST индекс
- сбалансированное дерево поиска как и b-tree
- но работает не только с сортируемыми данными (не только там где применимы > >= = < <=)
- используется для гео-данных, геометрических объектов

### SP-GiST индекс
- похож на GiST, но позволяет строить создавать несбалансированные деревья

### Составные индексы
- b-tree индекс может быть составным (многоколоночным)
- важен порядок колонок. Если индекс состоит из  col_1, col_2. То индексируемый поиск возможно по col_1, col_1 + col_2, но не по col_2
...

### Недостатки индексов
- занимают дополнительную память
- при вставке и удалении требуют перестроения, из-за чего операция выполняется дольше

### Индексы и сортировка
- Если сортировка происходит по колонке включенной в индекс, то сортировка отдельно не требуется

### Сбалансированное b-tree дерево
- ...

### Анализ запроса
explain [текст запроса]
```
EXPLAIN SELECT * FROM cusomer;
```

### Виды операции плана запроса

#### sequential scan
перебор всех строк  

#### index scan
- поиск по индексу, и обращение к основной таблице по указателям индекса
- также может использоваться при сортировке

#### index-only scan
- обращение только к индексу (когда индекс содержит необходимые данные)
- для корректной работы Index должен содержать информацию о том, что данные строки находятся на страницах, не подвергавшихся изменениям «в последнее время». То есть, для использования Index Only Scans ваша таблица должна быть хорошо вычищена с помощью vacuum. Но, с запущенным autovacuum это не должно стать проблемой.


#### Bitmap Index Scan
- всегда состоят, минимум, из двух узлов: Bitmap Index Scan, а затем – Bitmap Heap Scan
- Bitmap Index Scan создаст битовую карту, где каждой странице вашей таблицы будет соответствовать один бит. Все эти биты будут установлены в 0. Затем, Bitmap Index Scan установит некоторые биты в 1, в зависимости от того, на какой странице таблицы может находиться строка, которую нужно вернуть.
- Далее битовая карта перейдет на уровень выше, к узлу Bitmap Heap Scan, который читает их в более последовательной манере.

Обычные Index Scans вызывают случайные операции ввода/вывода – страницы с диска загружаются в случайном порядке. А это медленно. По крайней мере, на вращающихся дисках.

Bitmap Index Scans позволяет произвести последовательное чтение с диска.

#### BitmapOr BitmapAND
- Объединение битовых карт через логическое ИЛИ или И соответственно

#### Recheck Cond
- после чтения страницы из Bitmap Index Scan, надо перепроверить строки, так как не все строки страницы могут подходить под условие

#### HashAggregate
- Эта операция в основном применяется в случаях, когда вы используете GROUP BY и какие-нибудь агрегаты, вроде sum(), avg(), min(), max() и других.
- для каждой строки, которую получает, она находит «ключ» GROUP BY. Затем в хэше (ассоциативном массиве, словаре) помещает выбранную строку в корзину, обозначенную данным ключом.
- После того как все строки были обработаны, она сканирует хэш и возвращает по одной строке для каждого значения ключа, совершая уместные расчёты по необходимости (sum, min, avg и так далее).
  
#### Hash Join / Hash
- имеет две субоперации: “Hash" и что-нибудь другое.
- используется для объединения двух наборов записей
- сначала Hash Join вызывает “Hash", который в свою очередь вызывает что-нибудь ещё. Потом Hash создает в памяти (или на диске – в зависимости от размера) хэш/ассоциативный массив/словарь со строками из источника, хэшированными с помощью того, что используется для объединения данных.
- Потом Hash Join запускает вторую субоперацию и, для каждой строки из неё, делает следующее:
  - Проверяет, есть ли ключ join в хэше, возвращенном операцией Hash.
  - Если нет, данная строка из субоперации игнорируется (не будет возвращена).
  - Если ключ существует, Hash Join берет строки из хэша и, основываясь на этой строке, с одной стороны, и всех строках хэша, с другой стороны, генерирует вывод строк.
  
#### Nested Loop
- Nested Loop запускает первую сторону объединения единожды. Давайте назовем её “A".
- Для каждой строки из “A", запускается вторая операция (назовём её “B").
- Если “B" не вернула ни одной строки, данные из “A" игнорируются.
- Если “B" вернула строки, для каждой возвращаемой строки Nested Loop возвращает новую строку, основанную на текущих строках из A и B.

#### Merge Join
- используется, если объединяемые наборы данных отсортированы
- если объединяемый столбец справа такой же, как объединяемый столбец слева:
  - возвращаем новую объединённую строку, основанную на текущих строках справа и слева;
  - берем следующую строку справа (или слева, если справа больше нет строк);
  - возвращаемся к шагу 1;
- если объединяемый столбец справа «меньше», чем объединяемый столбец слева:
  - берем следующую строку справа (если строк больше нет, заканчиваем обработку);
  - возвращаемся к шагу 1;
- если объединяемый столбец справа «больше», чем объединяемый столбец слева:
  - берем следующую строку слева (если строк больше нет, заканчиваем обработку);
  - возвращаемся к шагу 1.

#### Модификаторы Hash Join / Nested Loop / Merge Join
- Hash Left Join,
- Hash Right Join,
- Merge Left Join,
- Merge Right Join,
- Nested Loop Left Join.
- Hash Full Join,
- Merge Full Join.
- Hash Anti Join,
- Merge Anti Join,
- Nested Loop Anti Join.

Anti Join выдаёт строку, только если правая сторона не находит ни одной строки. Это полезно, когда вы делаете что-нибудь, вроде “WHERE not exists ()" или “left join … where right_table.column is null

#### Materialize
Запоминает вывод чтобы избегать многкратного чтения в nested loop

### Другие инсайты
- Важно понимать, что порядок возврата строк не является каким-то определенным. Они возвращаются не «в порядке вставки» или «последняя обновленная строка – первой», или ещё что-то в том же духе. Параллельные выборки, обновления, удаления, чистки (vacuums) могут менять порядок следования строк в любое время.


### Ссылки
- https://postgrespro.ru/docs/postgresql/9.6/indexes-types
- https://tproger.ru/articles/indeksy-v-postgresql/
- https://habr.com/ru/post/275851/
- https://dba.stackexchange.com/questions/119386/understanding-bitmap-heap-scan-and-bitmap-index-scan